#!/bin/sh
#
# Download & apply the latest kernel binary from a master server.
#
# This eliminates the need to compile the same kernel on all servers instances.
# One master server compiles and offers the kernel, others can pull from there.
#
# NOTE: the kernel on the master domain has to be shared through https as
#       https://$DOMAIN/boot/#KERNEL-FILES#  (e.g.: ln -s /boot /var/www/)
#       Required shared files are generated by the SHARE=y parameter
#       during the kernel compilation, see the install script. 
#
# (cloux@rote.ch)
exec 2>&1

# We need to be root
if [ $(id -u) -ne 0 ]; then printf "Need to be root!\n"; exit 1; fi

# use configuration files to override the defaults above
MODULE_PATH=$(realpath "${0%/*}" 2>/dev/null)
[ -r "$MODULE_PATH/conf" ] && . "$MODULE_PATH/conf"
[ -r /etc/default/kernel-update ] && . /etc/default/kernel-update

# get the latest kernel version number from one of the domains
for DOMAIN in $PULL_FROM; do
	printf "Latest kernel on %s: " "$DOMAIN"
	LATEST=$(wget -qO- "https://$DOMAIN/boot/latest" 2>/dev/null)
	printf "%s\n" "$LATEST"
	[ "$LATEST" ] && break
done

if [ -z "$LATEST" ]; then
	printf "None of the domains share a new kernel.\n"
	exit 1
fi

if [ -e "/boot/vmlinuz-$LATEST" ]; then
	printf "This kernel is already installed.\n"
	exit
fi

printf "New Kernel %s is available\n" "$LATEST"

# download the new binary kernel
cd /boot || exit 1
KERNEL_FILES="config System.map modules vmlinuz"
for FILE in $KERNEL_FILES; do
	printf "Downloading %s ... " "$FILE"
	NEWFILE="${FILE}-$LATEST"
	[ "$FILE" = "modules" ] && NEWFILE="$NEWFILE.tgz"
	wget --no-verbose "https://$DOMAIN/boot/$NEWFILE" || exit 1
done
printf "Unpack modules into /lib/modules ..."
cd /lib/modules || exit 1
mv -f "/boot/modules-$LATEST.tgz" .
tar xzf "modules-$LATEST.tgz" || exit 1
rm -f "modules-$LATEST.tgz"
printf "OK\n"

# apply the new kernel
[ -x /usr/sbin/update-grub ] && /usr/sbin/update-grub

printf "\nDONE\n"
